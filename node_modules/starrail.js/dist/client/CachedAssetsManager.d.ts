import { ConfigFile, JsonArray, JsonElement, JsonObject } from "config_file.js";
import { ObjectKeysManager } from "./ObjectKeysManager";
import { StarRail } from "./StarRail";
export type ExcelKey = string | [string, JsonElement];
export declare const excelKeyMap: {
    readonly AvatarConfig: ["AvatarID"];
    readonly ItemConfigAvatar: ["ID"];
    readonly DamageType: ["ID"];
    readonly AvatarBaseType: [["ID", "Unknown"]];
    readonly AvatarSkillConfig: ["SkillID", "Level"];
    readonly AvatarServantSkillConfig: ["SkillID", "Level"];
    readonly AvatarSkillTreeConfig: ["PointID", "Level"];
    readonly AvatarRankConfig: ["RankID"];
    readonly AvatarPromotionConfig: ["AvatarID", ["Promotion", 0]];
    readonly AvatarSkin: ["ID"];
    readonly EquipmentConfig: ["EquipmentID"];
    readonly ItemConfigEquipment: ["ID"];
    readonly EquipmentExpType: ["ExpType", "Level"];
    readonly EquipmentSkillConfig: ["SkillID", "Level"];
    readonly EquipmentPromotionConfig: ["EquipmentID", ["Promotion", 0]];
    readonly RelicConfig: ["ID"];
    readonly ItemConfigRelic: ["ID"];
    readonly RelicExpType: ["TypeID", ["Level", 0]];
    readonly RelicMainAffixConfig: ["GroupID", "AffixID"];
    readonly RelicSubAffixConfig: ["GroupID", "AffixID"];
    readonly RelicSetConfig: ["SetID"];
    readonly RelicSetSkillConfig: ["SetID", "RequireNum"];
    readonly RelicBaseType: [["Type", "All"]];
    readonly AvatarPropertyConfig: ["PropertyType"];
    readonly ItemConfigAvatarPlayerIcon: ["ID"];
    readonly AvatarPlayerIcon: ["ID"];
    readonly ItemPlayerCard: ["ID"];
    readonly PlayerIcon: ["ID"];
};
export type ExcelType = keyof typeof excelKeyMap;
export declare const excels: ExcelType[];
export type LoadedExcelDataMap = {
    [excel in keyof typeof excelKeyMap]: SingleBy<typeof excelKeyMap[excel]>;
};
export type ExcelDataMap = {
    [excel in keyof typeof excelKeyMap]: LoadedExcelDataMap[excel] | null;
};
declare const languages: readonly ["chs", "cht", "de", "en", "es", "fr", "id", "jp", "kr", "pt", "ru", "th", "vi"];
export type LanguageCode = typeof languages[number];
export type LoadedLanguageMap = {
    [key in LanguageCode]: {
        [key: string]: string;
    };
};
export type LanguageMap = {
    [key in LanguageCode]: LoadedLanguageMap[key] | null;
};
export declare class CachedAssetsManager {
    /** The client that instantiated this */
    readonly client: StarRail;
    /** Default path of StarRail cache data directory */
    readonly defaultCacheDirectoryPath: string;
    /** List of the names of the files this library uses */
    readonly _excels: ExcelType[];
    /** List of supported languages */
    readonly _langs: typeof languages;
    /** Path of directory where StarRail cache data is stored */
    cacheDirectoryPath: string;
    _cacheUpdater: NodeJS.Timeout | null;
    _githubCache: ConfigFile | null;
    _isFetching: boolean;
    constructor(client: StarRail);
    /** Create the necessary folders and files, and if the directory [cacheDirectoryPath](#cacheDirectoryPath) did not exist, move the cache files from the default path. */
    cacheDirectorySetup(): Promise<void>;
    /** Obtains a text map for a specific language. */
    fetchLanguageData(lang: LanguageCode): Promise<{
        [key: string]: string;
    }>;
    /**
     * @param useRawStarRailData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/turnbasedgamedata}) instead of downloading cache.zip
     * @returns Whether the game data update is available or not.
     */
    checkForUpdates(useRawStarRailData?: boolean): Promise<boolean>;
    /**
     * @param options.useRawStarRailData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/turnbasedgamedata}) instead of downloading cache.zip
     * @param options.ghproxy Whether to use ghproxy.com
     */
    fetchAllContents(options: {
        useRawStarRailData?: boolean;
        ghproxy?: boolean;
    }): Promise<void>;
    /**
     * @returns whether all StarRail cache data files exist.
     */
    hasAllContents(): boolean;
    /**
     * @param options.useRawStarRailData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/turnbasedgamedata}) instead of downloading cache.zip
     * @param options.ghproxy Whether to use ghproxy.com
     * @returns true if there were any updates, false if there were no updates.
     */
    updateContents(options?: {
        useRawStarRailData?: boolean;
        ghproxy?: boolean;
        onUpdateStart?: () => Promise<void>;
        onUpdateEnd?: () => Promise<void>;
    }): Promise<void>;
    /**
     * @param options.useRawStarRailData Whether to fetch from gitlab repo ({@link https://gitlab.com/Dimbreath/turnbasedgamedata}) instead of downloading cache.zip
     * @param options.ghproxy Whether to use ghproxy.com
     * @param options.timeout in milliseconds
     */
    activateAutoCacheUpdater(options?: {
        useRawStarRailData?: boolean;
        instant?: boolean;
        ghproxy?: boolean;
        timeout?: number;
        onUpdateStart?: () => Promise<void>;
        onUpdateEnd?: () => Promise<void>;
        onError?: (error: Error) => Promise<void>;
    }): void;
    /**
     * Disables the updater activated by [activateAutoCacheUpdater](#activateAutoCacheUpdater)
     */
    deactivateAutoCacheUpdater(): void;
    /**
     * @returns text map file path for a specific language
     */
    getLanguageDataPath(lang: LanguageCode): string;
    /**
     * @param name without extensions (.json)
     * @returns excel bin file path
     */
    getJSONDataPath(name: string): string;
    /**
     * @param excel without extensions (.json)
     */
    _getExcelData<T extends ExcelType>(excel: T): SingleBy<typeof excelKeyMap[T]>;
    /**
     * @param excel without extension (.json)
     */
    getExcelData<T extends ExcelType, U extends (string | number)[]>(excel: T, ...keys: U): IndexBy<SingleBy<typeof excelKeyMap[T]>, U>;
    /**
     * @returns text map for a specific language
     */
    getLanguageData(lang: LanguageCode): {
        [key: string]: string;
    };
    /**
     * @returns ObjectKeysManager of this
     */
    getObjectKeysManager(): ObjectKeysManager;
    /**
     * Clean memory of cache data.
     * Then reload data that was loaded before the clean if `reload` is true.
     * If `reload` is false, load each file as needed.
     */
    refreshAllData(reload?: boolean): void;
    formatExcel<T extends ExcelType>(excel: T, data: JsonObject[]): SingleBy<typeof excelKeyMap[T]>;
    /**
     * Remove all unused text map entries
     */
    removeUnusedTextData(data: LoadedExcelDataMap, langsData: LoadedLanguageMap, showLog?: boolean): LoadedLanguageMap;
    /**
     * Download the zip file, which contains StarRail cache data, from {@link https://raw.githubusercontent.com/yuko1101/starrail.js/main/cache.zip}
     * @param options.ghproxy Whether to use ghproxy.com
     */
    _downloadCacheZip(options?: {
        ghproxy?: boolean;
    }): Promise<void>;
}
export type IndexBy<T, Keys extends (string | number)[]> = Keys extends [string | number, ...infer U] ? U extends (string | number)[] ? T extends JsonObject<infer V> ? IndexBy<V, U> | undefined : unknown : T extends JsonObject<infer V> ? V | undefined : unknown : T;
export declare function indexBy<T extends JsonObject, U extends (string | number)[]>(data: T, ...keys: U): IndexBy<T, U>;
export type SingleBy<Keys extends ExcelKey[]> = Keys extends [ExcelKey, ...infer T] ? T extends ExcelKey[] ? JsonObject<SingleBy<T>> : never : JsonObject;
export declare function singleBy<T extends ExcelKey[]>(array: JsonArray<JsonObject>, ...keys: T): SingleBy<T>;
export {};
